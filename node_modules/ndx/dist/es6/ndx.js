const WHITESPACE_RE = /[\s]+/;
/**
 * The whitespace tokenizer breaks on whitespace - spaces, tabs, line feeds and assumes that contiguous nonwhitespace
 * characters form a single token.
 */
function whitespaceTokenizer(text) {
    return text.trim().split(WHITESPACE_RE);
}

/**
 * Converts term to lower case.
 */
function lowerCaseFilter(term) {
    return term.toLowerCase();
}
const NWSTART_RE = /^\W+/;
const NWEND_RE = /\W+$/;
/**
 * Removes all non-word characters at the start and at the end of the term.
 */
function trimNonWordCharactersFilter(term) {
    return term.replace(NWSTART_RE, "").replace(NWEND_RE, "");
}

/**
 * Trie Node.
 */
class InvertedIndexNode {
    constructor(charCode) {
        this.charCode = charCode;
        this.next = null;
        this.firstChild = null;
        this.firstPosting = null;
    }
}
/**
 * Create trie nodes for the `term` starting from the `start` character.
 */
function createNodes(parent, term, start) {
    for (; start < term.length; start++) {
        const newNode = new InvertedIndexNode(term.charCodeAt(start));
        if (parent.firstChild === null) {
            parent.firstChild = newNode;
        }
        else {
            newNode.next = parent.firstChild;
            parent.firstChild = newNode;
        }
        parent = newNode;
    }
    return parent;
}
/**
 * Find trie child node that matches `charCode`.
 */
function findChild(node, charCode) {
    let child = node.firstChild;
    while (child !== null) {
        if (child.charCode === charCode) {
            return child;
        }
        child = child.next;
    }
    return undefined;
}
/**
 * Inverted Index implemented with a trie data structure.
 */
class InvertedIndex {
    constructor() {
        this.root = new InvertedIndexNode(0);
    }
    /**
     * Get trie node that matches the `term`.
     */
    get(term) {
        let node = this.root;
        for (let i = 0; i < term.length; i++) {
            node = findChild(node, term.charCodeAt(i));
            if (node === undefined) {
                return null;
            }
        }
        return node;
    }
    add(term, docDetails, termFrequency) {
        let node = this.root;
        for (let i = 0; i < term.length; i++) {
            if (node.firstChild === null) {
                node = createNodes(node, term, i);
                break;
            }
            const nextNode = findChild(node, term.charCodeAt(i));
            if (nextNode === undefined) {
                node = createNodes(node, term, i);
                break;
            }
            node = nextNode;
        }
        const pointer = {
            next: null,
            details: docDetails,
            termFrequency: termFrequency,
        };
        if (node.firstPosting === null) {
            node.firstPosting = pointer;
        }
        else {
            pointer.next = node.firstPosting;
            node.firstPosting = pointer;
        }
    }
    /**
     * Expand term with all indexed terms.
     */
    expandTerm(term) {
        const node = this.get(term);
        const results = [];
        if (node !== null) {
            _expandTerm(node, results, term);
        }
        return results;
    }
    /**
     * Remove outdated/removed documents from the index.
     */
    vacuum() {
        _vacuum(this.root);
    }
}
function _expandTerm(node, results, term) {
    if (node.firstPosting !== null && node.firstPosting !== null) {
        results.push(term);
    }
    let child = node.firstChild;
    while (child !== null) {
        _expandTerm(child, results, term + String.fromCharCode(child.charCode));
        child = child.next;
    }
}
function _vacuum(node) {
    let prevPointer = null;
    let pointer = node.firstPosting;
    while (pointer !== null) {
        if (pointer.details.removed) {
            if (prevPointer === null) {
                node.firstPosting = pointer.next;
            }
            else {
                prevPointer.next = pointer.next;
            }
        }
        else {
            prevPointer = pointer;
        }
        pointer = pointer.next;
    }
    let child = node.firstChild;
    while (child !== null) {
        _vacuum(child);
        child = child.next;
    }
}

function DEFAULT_FILTER(term) {
    return trimNonWordCharactersFilter(lowerCaseFilter(term));
}
/**
 * Document Index.
 */
class DocumentIndex {
    constructor(options) {
        this._documents = new Map();
        this._index = new InvertedIndex();
        this._fields = [];
        this._tokenizer = whitespaceTokenizer;
        this._filter = DEFAULT_FILTER;
        this._bm25k1 = 1.2;
        this._bm25b = 0.75;
        if (options !== undefined) {
            if (options.tokenizer !== undefined) {
                this._tokenizer = options.tokenizer;
            }
            if (options.filter !== undefined) {
                this._filter;
            }
            const bm25 = options.bm25;
            if (bm25 !== undefined) {
                if (bm25.k1 !== undefined) {
                    this._bm25k1 = bm25.k1;
                }
                if (bm25.b !== undefined) {
                    this._bm25b = bm25.b;
                }
            }
        }
    }
    /**
     * Returns number of indexed document.
     */
    get size() {
        return this._documents.size;
    }
    /**
     * Create Field Index.
     */
    addField(fieldName, options) {
        let getter = fieldName;
        let boost = 1;
        if (options !== undefined) {
            if (options.getter !== undefined) {
                getter = options.getter;
            }
            if (options.boost !== undefined) {
                boost = options.boost;
            }
        }
        const details = {
            name: fieldName,
            getter: getter,
            boost: boost,
            sumLength: 0,
            avgLength: 0,
        };
        this._fields.push(details);
    }
    /**
     * Add document to the index.
     */
    add(documentId, document) {
        const documentTermCounts = new Array(this._fields.length);
        const termCounts = new Map();
        for (let i = 0; i < this._fields.length; i++) {
            const fieldDetails = this._fields[i];
            const fieldAccessor = fieldDetails.getter;
            const fieldValue = typeof fieldAccessor === "string" ?
                document[fieldAccessor] :
                fieldAccessor(document);
            if (fieldValue === undefined) {
                documentTermCounts[i] = 0;
            }
            else {
                // tokenize text
                const terms = this._tokenizer(fieldValue);
                // filter and count terms, ignore empty strings
                let filteredTermsCount = 0;
                for (let j = 0; j < terms.length; j++) {
                    const term = this._filter(terms[j]);
                    if (term !== "") {
                        filteredTermsCount++;
                        let counts = termCounts.get(term);
                        if (counts === undefined) {
                            counts = new Array(this._fields.length).fill(0);
                            termCounts.set(term, counts);
                        }
                        counts[i] += 1;
                    }
                }
                fieldDetails.sumLength += filteredTermsCount;
                fieldDetails.avgLength = fieldDetails.sumLength / (this._documents.size + 1);
                documentTermCounts[i] = filteredTermsCount;
            }
        }
        const docDetails = {
            docId: documentId,
            removed: false,
            fieldLengths: documentTermCounts,
        };
        this._documents.set(documentId, docDetails);
        termCounts.forEach((termCounters, term) => {
            this._index.add(term, docDetails, termCounters);
        });
    }
    /**
     * Remove document from the index.
     */
    remove(documentId) {
        const details = this._documents.get(documentId);
        if (details !== undefined) {
            details.removed = true;
            this._documents.delete(documentId);
            for (let i = 0; i < this._fields.length; i++) {
                const fieldLength = details.fieldLengths[i];
                if (fieldLength > 0) {
                    const field = this._fields[i];
                    field.sumLength -= fieldLength;
                    field.avgLength = field.sumLength / this._documents.size;
                }
            }
        }
    }
    /**
     * Search with a free text query.
     *
     * All token separators work as a disjunction operator.
     */
    search(query) {
        const queryTerms = this._tokenizer(query);
        const scores = new Map();
        for (let i = 0; i < queryTerms.length; i++) {
            const term = this._filter(queryTerms[i]);
            if (term !== "") {
                const expandedTerms = this._index.expandTerm(term);
                const documents = new Set();
                for (let j = 0; j < expandedTerms.length; j++) {
                    const eTerm = expandedTerms[j];
                    const expansionBoost = eTerm === term ? 1 : Math.log(1 + (1 / (1 + eTerm.length - term.length)));
                    const termNode = this._index.get(eTerm);
                    if (termNode !== null && termNode.firstPosting !== null) {
                        let documentFrequency = 0;
                        let pointer = termNode.firstPosting;
                        let prevPointer = null;
                        while (pointer !== null) {
                            if (pointer.details.removed) {
                                if (prevPointer === null) {
                                    termNode.firstPosting = pointer.next;
                                }
                                else {
                                    prevPointer.next = pointer.next;
                                }
                            }
                            else {
                                prevPointer = pointer;
                                documentFrequency++;
                            }
                            pointer = pointer.next;
                        }
                        if (documentFrequency > 0) {
                            // calculating BM25 idf
                            const idf = Math.log(1 + (this.size - documentFrequency + 0.5) / (documentFrequency + 0.5));
                            pointer = termNode.firstPosting;
                            while (pointer !== null) {
                                if (!pointer.details.removed) {
                                    let score = 0;
                                    for (let x = 0; x < pointer.details.fieldLengths.length; x++) {
                                        let tf = pointer.termFrequency[x];
                                        if (tf > 0) {
                                            // calculating BM25 tf
                                            const fieldLength = pointer.details.fieldLengths[x];
                                            const fieldDetails = this._fields[x];
                                            const avgFieldLength = fieldDetails.avgLength;
                                            const k1 = this._bm25k1;
                                            const b = this._bm25b;
                                            tf = ((k1 + 1) * tf) / (k1 * ((1 - b) + b * (fieldLength / avgFieldLength)) + tf);
                                            score += tf * idf * fieldDetails.boost * expansionBoost;
                                        }
                                    }
                                    if (score > 0) {
                                        const docId = pointer.details.docId;
                                        const prevScore = scores.get(docId);
                                        if (prevScore !== undefined && documents.has(docId)) {
                                            scores.set(docId, Math.max(prevScore, score));
                                        }
                                        else {
                                            scores.set(docId, prevScore === undefined ? score : prevScore + score);
                                        }
                                        documents.add(docId);
                                    }
                                }
                                pointer = pointer.next;
                            }
                        }
                    }
                }
            }
        }
        const result = [];
        scores.forEach(function (score, documentId) {
            result.push({
                docId: documentId,
                score: score,
            });
        });
        result.sort(function (a, b) {
            return b.score - a.score;
        });
        return result;
    }
    /**
     * Expand term with all possible combinations.
     */
    expandTerm(term) {
        return this._index.expandTerm(term);
    }
    /**
     * Convert query to an array of terms.
     */
    queryToTerms(query) {
        let result = [];
        const tokens = this._tokenizer(query);
        for (let i = 0; i < tokens.length; i++) {
            const term = this._filter(tokens[i]);
            if (term !== "") {
                result = result.concat(this._index.expandTerm(term));
            }
        }
        return result;
    }
    /**
     * Remove outdated/removed documents from the index.
     */
    vacuum() {
        this._index.vacuum();
    }
}

export { whitespaceTokenizer, lowerCaseFilter, trimNonWordCharactersFilter, DocumentIndex, DEFAULT_FILTER };
