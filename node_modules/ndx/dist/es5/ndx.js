var WHITESPACE_RE = /[\s]+/;
/**
 * The whitespace tokenizer breaks on whitespace - spaces, tabs, line feeds and assumes that contiguous nonwhitespace
 * characters form a single token.
 */
function whitespaceTokenizer(text) {
    return text.trim().split(WHITESPACE_RE);
}

/**
 * Converts term to lower case.
 */
function lowerCaseFilter(term) {
    return term.toLowerCase();
}
var NWSTART_RE = /^\W+/;
var NWEND_RE = /\W+$/;
/**
 * Removes all non-word characters at the start and at the end of the term.
 */
function trimNonWordCharactersFilter(term) {
    return term.replace(NWSTART_RE, "").replace(NWEND_RE, "");
}

/**
 * Trie Node.
 */
var InvertedIndexNode = (function () {
    function InvertedIndexNode(charCode) {
        this.charCode = charCode;
        this.next = null;
        this.firstChild = null;
        this.firstPosting = null;
    }
    return InvertedIndexNode;
}());
/**
 * Create trie nodes for the `term` starting from the `start` character.
 */
function createNodes(parent, term, start) {
    for (; start < term.length; start++) {
        var newNode = new InvertedIndexNode(term.charCodeAt(start));
        if (parent.firstChild === null) {
            parent.firstChild = newNode;
        }
        else {
            newNode.next = parent.firstChild;
            parent.firstChild = newNode;
        }
        parent = newNode;
    }
    return parent;
}
/**
 * Find trie child node that matches `charCode`.
 */
function findChild(node, charCode) {
    var child = node.firstChild;
    while (child !== null) {
        if (child.charCode === charCode) {
            return child;
        }
        child = child.next;
    }
    return undefined;
}
/**
 * Inverted Index implemented with a trie data structure.
 */
var InvertedIndex = (function () {
    function InvertedIndex() {
        this.root = new InvertedIndexNode(0);
    }
    /**
     * Get trie node that matches the `term`.
     */
    InvertedIndex.prototype.get = function (term) {
        var node = this.root;
        for (var i = 0; i < term.length; i++) {
            node = findChild(node, term.charCodeAt(i));
            if (node === undefined) {
                return null;
            }
        }
        return node;
    };
    InvertedIndex.prototype.add = function (term, docDetails, termFrequency) {
        var node = this.root;
        for (var i = 0; i < term.length; i++) {
            if (node.firstChild === null) {
                node = createNodes(node, term, i);
                break;
            }
            var nextNode = findChild(node, term.charCodeAt(i));
            if (nextNode === undefined) {
                node = createNodes(node, term, i);
                break;
            }
            node = nextNode;
        }
        var pointer = {
            next: null,
            details: docDetails,
            termFrequency: termFrequency,
        };
        if (node.firstPosting === null) {
            node.firstPosting = pointer;
        }
        else {
            pointer.next = node.firstPosting;
            node.firstPosting = pointer;
        }
    };
    /**
     * Expand term with all indexed terms.
     */
    InvertedIndex.prototype.expandTerm = function (term) {
        var node = this.get(term);
        var results = [];
        if (node !== null) {
            _expandTerm(node, results, term);
        }
        return results;
    };
    /**
     * Remove outdated/removed documents from the index.
     */
    InvertedIndex.prototype.vacuum = function () {
        _vacuum(this.root);
    };
    return InvertedIndex;
}());
function _expandTerm(node, results, term) {
    if (node.firstPosting !== null && node.firstPosting !== null) {
        results.push(term);
    }
    var child = node.firstChild;
    while (child !== null) {
        _expandTerm(child, results, term + String.fromCharCode(child.charCode));
        child = child.next;
    }
}
function _vacuum(node) {
    var prevPointer = null;
    var pointer = node.firstPosting;
    while (pointer !== null) {
        if (pointer.details.removed) {
            if (prevPointer === null) {
                node.firstPosting = pointer.next;
            }
            else {
                prevPointer.next = pointer.next;
            }
        }
        else {
            prevPointer = pointer;
        }
        pointer = pointer.next;
    }
    var child = node.firstChild;
    while (child !== null) {
        _vacuum(child);
        child = child.next;
    }
}

function DEFAULT_FILTER(term) {
    return trimNonWordCharactersFilter(lowerCaseFilter(term));
}
/**
 * Document Index.
 */
var DocumentIndex = (function () {
    function DocumentIndex(options) {
        this._documents = new Map();
        this._index = new InvertedIndex();
        this._fields = [];
        this._tokenizer = whitespaceTokenizer;
        this._filter = DEFAULT_FILTER;
        this._bm25k1 = 1.2;
        this._bm25b = 0.75;
        if (options !== undefined) {
            if (options.tokenizer !== undefined) {
                this._tokenizer = options.tokenizer;
            }
            if (options.filter !== undefined) {
                this._filter;
            }
            var bm25 = options.bm25;
            if (bm25 !== undefined) {
                if (bm25.k1 !== undefined) {
                    this._bm25k1 = bm25.k1;
                }
                if (bm25.b !== undefined) {
                    this._bm25b = bm25.b;
                }
            }
        }
    }
    Object.defineProperty(DocumentIndex.prototype, "size", {
        /**
         * Returns number of indexed document.
         */
        get: function () {
            return this._documents.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create Field Index.
     */
    DocumentIndex.prototype.addField = function (fieldName, options) {
        var getter = fieldName;
        var boost = 1;
        if (options !== undefined) {
            if (options.getter !== undefined) {
                getter = options.getter;
            }
            if (options.boost !== undefined) {
                boost = options.boost;
            }
        }
        var details = {
            name: fieldName,
            getter: getter,
            boost: boost,
            sumLength: 0,
            avgLength: 0,
        };
        this._fields.push(details);
    };
    /**
     * Add document to the index.
     */
    DocumentIndex.prototype.add = function (documentId, document) {
        var _this = this;
        var documentTermCounts = new Array(this._fields.length);
        var termCounts = new Map();
        for (var i = 0; i < this._fields.length; i++) {
            var fieldDetails = this._fields[i];
            var fieldAccessor = fieldDetails.getter;
            var fieldValue = typeof fieldAccessor === "string" ?
                document[fieldAccessor] :
                fieldAccessor(document);
            if (fieldValue === undefined) {
                documentTermCounts[i] = 0;
            }
            else {
                // tokenize text
                var terms = this._tokenizer(fieldValue);
                // filter and count terms, ignore empty strings
                var filteredTermsCount = 0;
                for (var j = 0; j < terms.length; j++) {
                    var term = this._filter(terms[j]);
                    if (term !== "") {
                        filteredTermsCount++;
                        var counts = termCounts.get(term);
                        if (counts === undefined) {
                            counts = new Array(this._fields.length).fill(0);
                            termCounts.set(term, counts);
                        }
                        counts[i] += 1;
                    }
                }
                fieldDetails.sumLength += filteredTermsCount;
                fieldDetails.avgLength = fieldDetails.sumLength / (this._documents.size + 1);
                documentTermCounts[i] = filteredTermsCount;
            }
        }
        var docDetails = {
            docId: documentId,
            removed: false,
            fieldLengths: documentTermCounts,
        };
        this._documents.set(documentId, docDetails);
        termCounts.forEach(function (termCounters, term) {
            _this._index.add(term, docDetails, termCounters);
        });
    };
    /**
     * Remove document from the index.
     */
    DocumentIndex.prototype.remove = function (documentId) {
        var details = this._documents.get(documentId);
        if (details !== undefined) {
            details.removed = true;
            this._documents.delete(documentId);
            for (var i = 0; i < this._fields.length; i++) {
                var fieldLength = details.fieldLengths[i];
                if (fieldLength > 0) {
                    var field = this._fields[i];
                    field.sumLength -= fieldLength;
                    field.avgLength = field.sumLength / this._documents.size;
                }
            }
        }
    };
    /**
     * Search with a free text query.
     *
     * All token separators work as a disjunction operator.
     */
    DocumentIndex.prototype.search = function (query) {
        var queryTerms = this._tokenizer(query);
        var scores = new Map();
        for (var i = 0; i < queryTerms.length; i++) {
            var term = this._filter(queryTerms[i]);
            if (term !== "") {
                var expandedTerms = this._index.expandTerm(term);
                var documents = new Set();
                for (var j = 0; j < expandedTerms.length; j++) {
                    var eTerm = expandedTerms[j];
                    var expansionBoost = eTerm === term ? 1 : Math.log(1 + (1 / (1 + eTerm.length - term.length)));
                    var termNode = this._index.get(eTerm);
                    if (termNode !== null && termNode.firstPosting !== null) {
                        var documentFrequency = 0;
                        var pointer = termNode.firstPosting;
                        var prevPointer = null;
                        while (pointer !== null) {
                            if (pointer.details.removed) {
                                if (prevPointer === null) {
                                    termNode.firstPosting = pointer.next;
                                }
                                else {
                                    prevPointer.next = pointer.next;
                                }
                            }
                            else {
                                prevPointer = pointer;
                                documentFrequency++;
                            }
                            pointer = pointer.next;
                        }
                        if (documentFrequency > 0) {
                            // calculating BM25 idf
                            var idf = Math.log(1 + (this.size - documentFrequency + 0.5) / (documentFrequency + 0.5));
                            pointer = termNode.firstPosting;
                            while (pointer !== null) {
                                if (!pointer.details.removed) {
                                    var score = 0;
                                    for (var x = 0; x < pointer.details.fieldLengths.length; x++) {
                                        var tf = pointer.termFrequency[x];
                                        if (tf > 0) {
                                            // calculating BM25 tf
                                            var fieldLength = pointer.details.fieldLengths[x];
                                            var fieldDetails = this._fields[x];
                                            var avgFieldLength = fieldDetails.avgLength;
                                            var k1 = this._bm25k1;
                                            var b = this._bm25b;
                                            tf = ((k1 + 1) * tf) / (k1 * ((1 - b) + b * (fieldLength / avgFieldLength)) + tf);
                                            score += tf * idf * fieldDetails.boost * expansionBoost;
                                        }
                                    }
                                    if (score > 0) {
                                        var docId = pointer.details.docId;
                                        var prevScore = scores.get(docId);
                                        if (prevScore !== undefined && documents.has(docId)) {
                                            scores.set(docId, Math.max(prevScore, score));
                                        }
                                        else {
                                            scores.set(docId, prevScore === undefined ? score : prevScore + score);
                                        }
                                        documents.add(docId);
                                    }
                                }
                                pointer = pointer.next;
                            }
                        }
                    }
                }
            }
        }
        var result = [];
        scores.forEach(function (score, documentId) {
            result.push({
                docId: documentId,
                score: score,
            });
        });
        result.sort(function (a, b) {
            return b.score - a.score;
        });
        return result;
    };
    /**
     * Expand term with all possible combinations.
     */
    DocumentIndex.prototype.expandTerm = function (term) {
        return this._index.expandTerm(term);
    };
    /**
     * Convert query to an array of terms.
     */
    DocumentIndex.prototype.queryToTerms = function (query) {
        var result = [];
        var tokens = this._tokenizer(query);
        for (var i = 0; i < tokens.length; i++) {
            var term = this._filter(tokens[i]);
            if (term !== "") {
                result = result.concat(this._index.expandTerm(term));
            }
        }
        return result;
    };
    /**
     * Remove outdated/removed documents from the index.
     */
    DocumentIndex.prototype.vacuum = function () {
        this._index.vacuum();
    };
    return DocumentIndex;
}());

export { whitespaceTokenizer, lowerCaseFilter, trimNonWordCharactersFilter, DocumentIndex, DEFAULT_FILTER };
